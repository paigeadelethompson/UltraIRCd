/*
 *  ircd-hybrid: an advanced, lightweight Internet Relay Chat Daemon (ircd)
 *
 *  Copyright (c) 1997-2025 ircd-hybrid development team
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
 *  USA
 */

/**
 * @file log.c
 * @brief Implements a versatile logging system with support for multiple log types and rotation capabilities.
 *
 * This module offers a robust logging infrastructure designed for integration into IRC servers and similar applications.
 * It provides flexibility through various log types, file rotation mechanisms, and configurable logging behaviors.
 */

#include "stdinc.h"
#include "list.h"
#include "log.h"
#include "io_string.h"
#include "conf.h"
#include "misc.h"
#include "memory.h"

/* ANSI color codes for 24-bit color support */
#define COLOR_RESET "\033[0m"
#define COLOR_BOLD "\033[1m"

/* Severity level colors */
static const char *severity_colors[] = {
  "\033[38;2;128;128;128m",  /* DEBUG - Gray */
  "\033[38;2;0;255;0m",      /* INFO - Green */
  "\033[38;2;0;191;255m",    /* NOTICE - Deep Sky Blue */
  "\033[38;2;255;165;0m",    /* WARN - Orange */
  "\033[38;2;255;0;0m",      /* ERROR - Red */
  "\033[38;2;128;0;128m",    /* CRITICAL - Purple */
};

/* Log type colors */
static const char *type_colors[] = {
  "\033[38;2;0;191;255m",    /* IRCD - Deep Sky Blue */
  "\033[38;2;255;0;0m",      /* KILL - Red */
  "\033[38;2;255;165;0m",    /* KLINE - Orange */
  "\033[38;2;255;0;0m",      /* DLINE - Red */
  "\033[38;2;255;0;0m",      /* XLINE - Red */
  "\033[38;2;255;165;0m",    /* RESV - Orange */
  "\033[38;2;0;255;0m",      /* OPER - Green */
  "\033[38;2;0;191;255m",    /* USER - Deep Sky Blue */
  "\033[38;2;128;128;128m",  /* DEBUG - Gray */
};

/* Severity level strings */
static const char *severity_strings[] = {
  "DEBUG",
  "INFO",
  "NOTICE",
  "WARN",
  "ERROR",
  "CRITICAL",
};

/* Log type strings */
static const char *type_strings[] = {
  "IRCD",
  "KILL",
  "KLINE",
  "DLINE",
  "XLINE",
  "RESV",
  "OPER",
  "USER",
  "DEBUG",
};

/**
 * @def TRUNCATED_STRING
 * @brief A string indicating that log message content has been truncated.
 *
 * If a log message exceeds the maximum allowed length, it is truncated,
 * and this string is appended to indicate the truncation.
 */
#define TRUNCATED_STRING "[...truncated]"

/**
 * @var LOG_MAX_LENGTH
 * @brief Maximum length allowed for a log message, excluding null-terminator.
 *
 * This constant defines the maximum length a log message can have before
 * it gets truncated. Log messages exceeding this length will be truncated
 * with the TRUNCATED_STRING appended.
 */
enum { LOG_MAX_LENGTH = 512 };

/**
 * @var LOG_ROTATION_ATTEMPTS
 * @brief Maximum number of attempts to find a new file name during log rotation.
 *
 * During log rotation, a new file name is generated by appending a number to
 * the original file name. This constant represents the maximum number of attempts
 * to find an available file name in case of clashes.
 */
enum { LOG_ROTATION_ATTEMPTS = 1000 };

/**
 * @brief Initializes the logging system with a specific log type, severity, file name, maximum file size, and flush behavior.
 *
 * This function creates and initializes a new log, setting its attributes, opening the log file, and adding it to the log list.
 * In case of failure, it prints an error message and exits if it's the main log; otherwise, it returns NULL.
 *
 * @param type The type of the log entry.
 * @param severity The severity level for the log entries.
 * @param main Flag indicating if it's the primary log.
 * @param max_file_size Maximum size for the log file.
 * @param file_name Name of the log file.
 * @return A pointer to the initialized Log structure, or NULL on failure.
 */
struct Log *
log_add(enum log_type type, enum log_severity severity, bool main, size_t max_file_size, const char *file_name)
{
  struct Log *log = io_calloc(sizeof(struct Log));
  if (!log)
    return NULL;

  log->type = type;
  log->severity = severity;
  log->main = main;
  log->max_file_size = max_file_size;
  log->flush_immediately = true;
  log->time_provider = date_iso8601_usec;

  if (file_name)
  {
    log->file_name = io_strdup(file_name);
    if (strcmp(file_name, "stdout") == 0)
      log->file = stdout;
    else
      log->file = fopen(file_name, "a");
  }

  return log;
}

/**
 * @brief Writes a log entry with a variable argument list to the appropriate output.
 *
 * This function writes a log entry to the configured output (file or stdout) with color-coded severity and type.
 * It formats the message with timestamp, severity, type, and the actual message.
 *
 * @param type The type of the log entry.
 * @param severity The severity level of the log entry.
 * @param format The format string for the log entry.
 * @param ... Variable argument list for the log entry.
 */
void
log_write(enum log_type type, enum log_severity severity, const char *format, ...)
{
  if (ConfigLog.use_logging == 0)
    return;

  char buffer[LOG_MAX_LENGTH + 1];  /* +1 for the null terminator ('\0'). */
  va_list args;
  va_start(args, format);
  size_t length = vsnprintf(buffer, sizeof(buffer), format, args);
  va_end(args);

  /* Check if log message was truncated. */
  if (length >= sizeof(buffer))
    strlcpy(buffer + LOG_MAX_LENGTH - sizeof(TRUNCATED_STRING), TRUNCATED_STRING, sizeof(TRUNCATED_STRING));

  /* Remove "ERROR: " prefix if present and severity is ERROR or CRITICAL */
  char *message = buffer;
  if ((severity == LOG_SEVERITY_ERROR || severity == LOG_SEVERITY_CRITICAL) && 
      strncmp(message, "ERROR: ", 7) == 0)
    message += 7;

  /* Write to stderr with color coding */
  fprintf(stderr, "%s[%s]%s %s%s%s %s%s%s %s%s%s\n",
          COLOR_BOLD,
          date_iso8601_usec(0),
          COLOR_RESET,
          severity_colors[severity],
          severity_strings[severity],
          COLOR_RESET,
          type_colors[type],
          type_strings[type],
          COLOR_RESET,
          severity_colors[severity],
          message,
          COLOR_RESET);
  fflush(stderr);
}

/**
 * @brief Closes, deinitializes, and frees a log.
 *
 * This function is now a no-op since we're only logging to stderr.
 */
void
log_destroy(struct Log *log)
{
}

/**
 * @brief Closes, deinitializes, and frees all logs.
 *
 * This function is now a no-op since we're only logging to stderr.
 */
void
log_clear(void)
{
}
